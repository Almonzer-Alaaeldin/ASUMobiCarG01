#include <interpreter.h>
#include <threeBytes.h>

int lineTrcSpe=43;              //for the line tracker mode
float Pweight=6 , Iweight=0.02 , Dweight=27;   //These are the weights for every value in PID method used in line tracker to be tunned
#define maxObst     9             //for tuning max obstacle distance in cm
#define spedSound 0.0343           //speed of sound in cm/us

int  digisped=80;    //for keypad speed and turning
bool reverseDirections=0;    

#define LmotorFor       2  //IN1       l298n   motor drive module
#define LmotorBac       3  //IN2
#define LmotorSpe       5  //EN1          
#define RmotorFor       4  //IN3
#define RmotorBac       7  //IN4
#define RmotorSpe       6  //EN2

#define trigUltra       8  //ultra sonic module trigger pin
#define echoUltra       9  //ultra sonic module echo pin

#define phot_ntrpt_l   18  
#define phot_ntrpt_r   17

#define lineTrcVL      19      //the very left //we can use analog pins as digital pins by using numbers from 14-19
#define lineTrcL       10      //the left 
#define lineTrcM       11      //the middle line track sensor
#define lineTrcR       12      //the right 
#define lineTrcVR      13      //the very right

#define Battery1        0
#define Battery2        1
#define BatteryAll      2    

int mov=0 , trn=0 ; //for movement
int dis=0  ; //for ultrasonic sensor
char reading=0 ;  //for blue-tooth readings
bool lineTrc =0  , accDrive=1 , allow=0   , allowObst=0;  //flag for modes , allowing movement , allowing obstacle avoidance
int lineTrcTurn=0 , turnWeight=0 , lastTurn=0;
int P=0 , I=0 , D=0 ;   //using the PID method to increase efficiency of line tracking
float  turnValue=0;     
int BatteryLevel1,BatteryLevel2 , Battery , col;        //Batteries ,   col=>indicator color
bool Bat1 , Bat2;
interpreter trans;
threeBytes stor[450];
String readin="";
bool valid=0 , start=0;
int instructionNum=0 , currentIndex=0 , loopingIndex=0 ;

 

void moveCar(int movement , int turning) //takes percentage of movement and turning the analog stick is reversed in the y direction in the app, up is negative and down is positive
{  
  if(reverseDirections)
  {
    movement*=-1;
    if(movement!=0)turning*=-1;
  }                                     //positive for backward movement and right turning  negative for forward movement and left turning
  if(movement==0&&turning==0)
  {
    digitalWrite(LmotorFor,LOW);
    digitalWrite(LmotorBac,LOW);  //all pins LOW to stop the car and conserve power
    digitalWrite(LmotorSpe,LOW);
    digitalWrite(RmotorFor,LOW);
    digitalWrite(RmotorBac,LOW);
    digitalWrite(RmotorSpe,LOW);
  }
  else
  {
    int left=0 ,right=0 ;       //speed of each wheel
    bool forL=LOW , forR=LOW;     //Direction of each wheel
    if(movement>0)
    {
      turning = -1*turning;     //when moving backwards the turning value is reversed
    }
    right=turning;					//right = movement+turning
    left =-1*right;					//left = movement-turning
    left=left+ movement;      
    right=right+movement;
    if (right<0)          //test for negative values to determine direction then make them positive for using
    {
      forR=HIGH;
      right=0-right;
    } 
    else forR=LOW;
    if (left<0)
    {
      forL=HIGH;
      left=0-left;
    }
    else forL=LOW;

    right=map(right,0,100,90,255); 
    left=map(left,0,100,90,255);
    left=constrain(left,0,255);
    right=constrain(right,0,255);
    
    Serial.print("*C"+String(left)+"*");
    Serial.print("*E"+String(right)+"*");
    digitalWrite(LmotorFor,forL);
    digitalWrite(LmotorBac,!forL);
    analogWrite(LmotorSpe,left);
    digitalWrite(RmotorFor,forR);
    digitalWrite(RmotorBac,!forR);
    analogWrite(RmotorSpe,right);
  }
}

int obstEcho()          //the generic code for the ultrasonic module
{
  int tim=0;
  digitalWrite(trigUltra, LOW);
  delayMicroseconds(2);
  digitalWrite(trigUltra, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigUltra, LOW);
  tim= pulseIn(echoUltra, HIGH);
  return tim;
}

void BatteryIndicate()
{
  BatteryLevel1=map(analogRead(Battery1),0,1024,0,500);
  BatteryLevel2=map(analogRead(Battery2),0,1024,0,500);
  Battery=map(analogRead(BatteryAll),0,945,0,850);
  Bat1=(BatteryLevel1<=280);
  Bat2=(BatteryLevel2<=280);
  Serial.print("*B"+String(Battery)+"**L"+String(BatteryLevel1)+"**l"+String(BatteryLevel2)+"*");
  col=255*Bat1;
  Serial.print("*HR"+String(col)+"G0B0*");
  col=255*Bat2;
  Serial.print("*hR"+String(col)+"G0B0*");
}
String removeAllWhite(String arg)
{
    int j=0 , l=arg.length();
    for (int i=0;i<l;i++)
    {
        if(arg[i]==' ')
        {
            if(i!=0)j=i;
            while((arg[i]==' '||arg[i]=='\t')&&i<l)i++;

            arg=arg.substring(0,j)+arg.substring(i,l-1);
            l=arg.length();

            i-=i-j;
        }
    }
    return arg;
}
int findChar( String arg , char fnd)
{
  int l=arg.length();
  for(int i=0;i<l/2;i++)
  {
    if(arg[i]==fnd)return i;
    else if(arg[l-i-1]==fnd)return l-i-1;
  }
  return 0;
}

void setup() 
{
  Serial.begin(9600);
  pinMode(LmotorFor,OUTPUT);
  pinMode(LmotorBac,OUTPUT);
  pinMode(LmotorSpe,OUTPUT);
  pinMode(RmotorFor,OUTPUT);
  pinMode(RmotorBac,OUTPUT);
  pinMode(RmotorSpe,OUTPUT);

  pinMode(trigUltra,OUTPUT);
  pinMode(echoUltra,INPUT);

  pinMode(lineTrcVL,INPUT);
  pinMode(lineTrcL,INPUT);
  pinMode(lineTrcM,INPUT);
  pinMode(lineTrcR,INPUT);
  pinMode(lineTrcVR,INPUT);

  pinMode(phot_ntrpt_l,INPUT);
  pinMode(phot_ntrpt_r,INPUT);

}

void loop() 
{
  BatteryIndicate();
  if(allowObst)
  {
    dis=obstEcho()*spedSound/2;   
    Serial.print("*X"+String(dis)+"*");    //displaying distance of nearest obstacle on the control device
  }
  
  if (abs(dis)<=maxObst&&allowObst==HIGH)        //obstacle avoidance feature
  {
    Serial.print("*AR255G0B0*");      //sending an alarming signal to control device
    moveCar(0,0);
    while(abs(dis)<=maxObst)
    {
      if(lineTrc==0)          //if line tracker mode is active the car will stop at obstacles else it will change its direction
      {
        moveCar(0,digisped);    //turn right
        delay(500);             //for half a second
        moveCar(0,0);           //stop 
      }
      else
      {
        moveCar(0,0);
      }
      dis=obstEcho()*spedSound/2;
      Serial.print("*X"+String(dis)+"*");
      if(dis>maxObst)Serial.print("*AR0G0B0*");     //turning off the alarm signal before exiting the loop
    } 
  }

  if (lineTrc==1 && accDrive==0)               //line tracker mode
  {
    
      //treating the sensors readings as a binary value and converting into decimal
    lineTrcTurn=(!digitalRead(lineTrcVL))*16+(digitalRead(lineTrcL))*8+(digitalRead(lineTrcM))*4+(digitalRead(lineTrcR))*2+(!digitalRead(lineTrcVR));
    switch (lineTrcTurn)
    {
      case 1:                 //  0 0 0 0 1    ->    8
        turnWeight=8;
      break;

      case 3:                 //  0 0 0 1 1    ->   6
        turnWeight=6;
      break;

      case 2:                 //  0 0 0 1 0    ->   4
        turnWeight=4;
      break;

      case 6:                 //  0 0 1 1 0    ->   2
        turnWeight=2;
      break;

      case 4:                 //  0 0 1 0 0    ->   0
        turnWeight=0;
      break;

      case 12:                //  0 1 1 0 0    ->   -2
        turnWeight=-2;
      break;

      case 8:                 //  0 1 0 0 0    ->   -4
        turnWeight=-4;
      break;

      case 24:                //  1 1 0 0 0    ->   -6
        turnWeight=-6;
      break;

      case 16:                //  1 0 0 0 0    ->   -8
        turnWeight=-8;
      break;

      case 0:                 //  0 0 0 0 0    ->   {-9,-7,-5,-3,-1,1,3,5,7,9}(depend on previous state)(intermidiate values for thin tracks)
        if(turnWeight==-4||(turnWeight!=4&&D<0))turnWeight=-5;      //if it was left turn more left
        else if(turnWeight==4||D>0) turnWeight=5;           //if it was right turn more right
      break;

      default:
        turnWeight=0;             // at conflict move straight
      break;


    }
    P=turnWeight;                   //the proportional value is the current turn weight based on current sensor reading
    I=I+turnWeight;                   //the integral value is the accumulation of all the previous turn weights (readings)
    D=turnWeight-lastTurn;                //the differential value is the difference between current and last turn weights
    turnValue=(P*Pweight)+(I*Iweight)+(D*Dweight);    //finally the turning value which will control the response of the car is the sum of all values
    lastTurn=turnWeight;                //each multiplied by their respective weights
    turnValue=constrain(turnValue,-100,100);
    if(allow==HIGH)
    {moveCar(-1*lineTrcSpe,turnValue);}

    Serial.print("*p");
    Serial.print(P);  //displaying current P on the control device
    Serial.print("*");
    Serial.print("*i");
    Serial.print(I);  //displaying current I on the control device
    Serial.print("*");
    Serial.print("*d");
    Serial.print(D);  //displaying current D on the control device
    Serial.print("*");

  }

  if (Serial.available()>0)     //blue-tooth mode
  {
    reading=Serial.read();
    if(lineTrc==0&&accDrive==0)
    {
      switch (reading)
      {
        case 'X' :    //the analog pad reading send   X....Y....
          trn=Serial.parseInt();
          reading=Serial.read();
          if(reading=='Y')
          {
            mov=Serial.parseInt();
            moveCar(mov,trn);
          }
        break;

        case 'N' :    //keypad button up
          moveCar(-1*digisped,0);
        break;

        case 'S' :    //keypad button down
          moveCar(digisped,0);
        break;

        case 'E' :    //keypad button right
          moveCar(0,digisped);
        break;

        case 'W' :    //keypad button left
          moveCar(0,-1*digisped);
        break;

        case 'R' :    //keypad button up right
          moveCar(-1*digisped,digisped);
        break;

        case 'L' :    //keypad button up left
          moveCar(-1*digisped,-1*digisped);
        break;

        case 'A' :    //keypad button down right 
          moveCar(digisped,digisped);
        break;

        case 'B' :    //keypad button down left 
          moveCar(digisped,-1*digisped);
        break;

        case 'M' :    //keypad button release and brake button
          moveCar(0,0);
        break;

        case 'C' :    //line tracker activator
          accDrive=0;
          lineTrc=1;
          moveCar(0,0);
          Serial.print("*P");
          Serial.print(Pweight);  //displaying current Pweight on the control device
          Serial.print("*");
          Serial.print("*I");
          Serial.print(Iweight);  //displaying current Iweight on the control device
          Serial.print("*");
          Serial.print("*D");
          Serial.print(Dweight);  //displaying current Dweight on the control device
          Serial.print("*");
          Serial.print("*S");
          Serial.print(lineTrcSpe); //displaying current speed on the control device
          Serial.print("*");
        break;
        
        case 'O':       //for  turning on obstacle avoidance
          allowObst=HIGH;
        break;
      
        case 'o':       //for  turning off obstacle avoidance
          allowObst=LOW;
        break;
        
        case 'Q' :    //Accurate driving mode
          accDrive=1;
          lineTrc=0;
        break;
        
        case 'J':
          digisped=Serial.parseInt();
          Serial.print("*j"+String(digisped)+"*");
        break;
        
        case 'V' :    //Accurate driving mode
          reverseDirections=1;
        break;

        case 'v' :    //Accurate driving mode
          reverseDirections=0;
        break;
        
        default :
          moveCar(0,0);
        break;
      }
    }
    else if(lineTrc==1&&accDrive==0)
    {
      switch (reading)
      {
        case 'c':
          lineTrc=0;
          moveCar(0,0);
          P=0;
          I=0;
          D=0;
        break;
        
        case 'Q' :    //Accurate driving mode
          accDrive=1;
          lineTrc=0;
        break;
        
        case 'Z':
          allow=HIGH;
        break;
        
        case 'z':
          moveCar(0,0);
          allow=LOW;
        break;

        case 'r':       //for  resetting values
          P=0;
          I=0;
          D=0;
        break;
        
        case 'P':       //for tuning Pweight on the fly
          Pweight=Serial.parseFloat();
          Serial.print("*P");
          Serial.print(Pweight);  //displaying current Pweight on the control device
          Serial.print("*");
        break;

        case 'I':       //for tuning Iweight on the fly
          Iweight=Serial.parseFloat();
          Serial.print("*I");
          Serial.print(Iweight);  //displaying current Iweight on the control device
          Serial.print("*");
        break;

        case 'D':       //for tuning Dweight on the fly
          Dweight=Serial.parseFloat();
          Serial.print("*D");
          Serial.print(Dweight);  //displaying current Dweight on the control device
          Serial.print("*");
        break;

        case 's':       //for tuning speed on the fly
          lineTrcSpe=Serial.parseInt();
          lineTrcSpe=constrain(lineTrcSpe,-100,100);
          Serial.print("*S");
          Serial.print(lineTrcSpe); //displaying current speed on the control device
          Serial.print("*");
        break;
      }

    }
    else if(accDrive==1&&lineTrc==0)    //accurate drive mode
    {
      switch (reading)
      {
        case 'q' :    //Accurate driving mode
          accDrive=0;
          Serial.print("Going to easy drive mode.\n");
        break;

        case 'C' :    //line tracker activator
          Serial.print("Going to line tracker mode.\n");
          accDrive=0;
          lineTrc=1;
          accDrive=0;
          moveCar(0,0);
          Serial.print("*P");
          Serial.print(Pweight);  //displaying current Pweight on the control device
          Serial.print("*");
          Serial.print("*I");
          Serial.print(Iweight);  //displaying current Iweight on the control device
          Serial.print("*");
          Serial.print("*D");
          Serial.print(Dweight);  //displaying current Dweight on the control device
          Serial.print("*");
          Serial.print("*S");
          Serial.print(lineTrcSpe); //displaying current speed on the control device
          Serial.print("*");
        break;
        
        case 'R' :
          while(readin!="STOPREADING"&&readin!="STOPREADIN"&&readin!="STOP_READING"&&readin!="r"&&readin!="START")
          {
            if(Serial.available())
            {
              readin=Serial.readStringUntil(';');
              if(readin=="r"||readin=="S")continue;
              readin=removeAllWhite(readin);
              readin.toUpperCase();
              if(readin=="STOPREADING"||readin=="STOPREADIN"||readin=="STOP_READING"||readin=="START")continue;
              int Stringlength=readin.length();
              Serial.print(readin+";\n");
              if(readin[0]=="L"||readin[0]=="A"||readin[0]=="R"||readin[0]=="I"||readin[0]=="G")
              {
                trans.putInst(readin[0]);
                if(!trans.putArg1(readin.substring(1,Stringlength-1).toInt()))
                {
                  Serial.print("Argument 1 not Valid.\n");
                  valid=0;
                }
                else if(!trans.putArg2(readin.substring(findChar(readin,','),Stringlength-1).toInt()))
                {
                  Serial.print("Argument 2 not Valid.\n");
                  valid=0;
                }
                else
                {
                  Serial.print("OK\n");
                  valid=1;
                }
                
              }
              else if(readin[0]=="D")
              {
                long millsecnds=readin.substring(1,Stringlength-1).toInt();
                if(millsecnds>=1000000)
                {
                  Serial.print("Argument not Valid.\n");
                  valid=0;
                }
                else
                {
                 trans.putInst(readin[0]);
                 trans.putArg1(millsecnds%1000);
                 trans.putArg2(millsecnds/1000); 
                 valid=1;
                }
                
                
                
              }
              else
              {
                Serial.print("Command not allowed.\n");
                valid=0;
              }
            }
            if(valid==1)
            {
              if(instructionNum<500)
              {
                stor[instructionNum].store(trans.encode());
                instructionNum++;
                Serial.print("instruction  saved\n");
              }
              else
              {
                Serial.print("Maximum instructions reached\ninstruction not saved\n");
              }
            }
          }
          
          readin="";
        break;
        
        
      }
    }
    
    
  }

}

