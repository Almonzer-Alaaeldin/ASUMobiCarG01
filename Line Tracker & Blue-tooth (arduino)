int lineTrcSpe=70;              //for the line tracker mode
float Pweight=20 , Iweight=0 , Dweight=0;   //These are the weights for every value in PID method used in line tracker to be tunned
#define maxObst     9             //for tuning max obstacle distance in cm
#define spedSound 0.0343           //speed of sound in cm/us

#define digisped  80
#define digiturn  80    //for keypad speed and turning

#define LmotorFor       2  //IN1       l298n   motor drive module
#define LmotorBac       3  //IN2
#define LmotorSpe       5  //EN1          
#define RmotorFor       4  //IN3
#define RmotorBac       7  //IN4
#define RmotorSpe       6  //EN2

#define trigUltra    8     //ultra sonic module trigger pin
#define echoUltra    9     //ultra sonic module echo pin

#define lineTrcVL     19      //the very left //we can use analog pins as digital pins by using numbers from 14-19
#define lineTrcL      10      //the left 
#define lineTrcM      11      //the middle line track sensor
#define lineTrcR      12      //the right 
#define lineTrcVR     13      //the very right

#define Battery1       3
#define Battery2       2
#define Battery1low    18  
#define Battery2low    15
#define BatteryAll     0    

int mov=0 , trn=0 ; //for movement
int dis=0  ; //for ultrasonic sensor
char reading=0 ;  //for blue-tooth readings
bool lineTrc =0 , allow=0 ;  //flag for the line tracker mode
bool sharpRightSens , sharpLeftSens , normRightSens , normLeftSens , middleSens;
int lineTrcTurn=0 , turnWeight=0 , lastTurn=0;
int P=0 , I=0 , D=0 ;   //using the PID method to increase efficiency of line tracking
float  turnValue=0;     
int BatteryLevel1,BatteryLevel2 , Battery , col;        //Batteries ,   col=>indicator color
bool Bat1 , Bat2;

void moveCar(int movement , int turning) //takes percentage of movement and turning the analog stick is reversed in the y direction in the app, up is negative and down is positive
{                                       //positive for backward movement and right turning  negative for forward movement and left turning
  if(movement==0&&turning==0)
  {
    digitalWrite(LmotorFor,LOW);
    digitalWrite(LmotorBac,LOW);  //all pins LOW to stop the car and conserve power
    digitalWrite(LmotorSpe,LOW);
    digitalWrite(RmotorFor,LOW);
    digitalWrite(RmotorBac,LOW);
    digitalWrite(RmotorSpe,LOW);
  }
  else
  {
    int left=0 ,right=0 ;       //speed of each wheel
    bool forL=LOW , forR=LOW;     //Direction of each wheel
    if(movement>0)
    {
      turning =-1*turning;     //when moving backwards the turning value is reversed
    }
    right=turning;
    left =-1*right;
    left=left+ movement;      
    right=right+movement;
    if (right<0)          //test for negative values to determine direction then make them positive for using
    {
      forR=HIGH;
      right=0-right;
    } 
    else forR=LOW;
    if (left<0)
    {
      forL=HIGH;
      left=0-left;
    }
    else forL=LOW;

    right=map(right,0,100,90,255); 
    left=map(left,0,100,90,255);
    left=constrain(left,0,255);
    right=constrain(right,0,255);
    
    Serial.print("*C"+String(left)+"*");
    Serial.print("*E"+String(right)+"*");
    digitalWrite(LmotorFor,forL);
    digitalWrite(LmotorBac,!forL);
    analogWrite(LmotorSpe,left);
    digitalWrite(RmotorFor,forR);
    digitalWrite(RmotorBac,!forR);
    analogWrite(RmotorSpe,right);
  }
}

int obstEcho()          //the generic code for the ultrasonic module
{
  int tim=0;
  digitalWrite(trigUltra, LOW);
  delayMicroseconds(2);
  digitalWrite(trigUltra, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigUltra, LOW);
  tim= pulseIn(echoUltra, HIGH);
  return tim;
}

void BatteryIndicate()
{
  BatteryLevel1=map(analogRead(Battery1),0,1024,0,500);
  BatteryLevel2=map(analogRead(Battery2),0,1024,0,500);
  Battery=map(analogRead(BatteryAll),0,945,0,850);
  Bat1=digitalRead(Battery1low);
  Bat2=digitalRead(Battery2low);
  Serial.print("*B"+String(Battery)+"**L"+String(BatteryLevel1)+"**l"+String(BatteryLevel2)+"*");
  col=255*Bat1;
  Serial.print("*HR"+String(col)+"G0B0*");
  col=255*Bat2;
  Serial.print("*hR"+String(col)+"G0B0*");
}
void setup() 
{
 Serial.begin(38400);
 pinMode(LmotorFor,OUTPUT);
 pinMode(LmotorBac,OUTPUT);
 pinMode(LmotorSpe,OUTPUT);
 pinMode(RmotorFor,OUTPUT);
 pinMode(RmotorBac,OUTPUT);
 pinMode(RmotorSpe,OUTPUT);

 pinMode(trigUltra,OUTPUT);
 pinMode(echoUltra,INPUT);

 pinMode(lineTrcVL,INPUT);
 pinMode(lineTrcL,INPUT);
 pinMode(lineTrcM,INPUT);
 pinMode(lineTrcR,INPUT);
 pinMode(lineTrcVR,INPUT);
 
 pinMode(Battery1low,INPUT);
 pinMode(Battery2low,INPUT);

}

void loop() 
{
  BatteryIndicate();
  dis=obstEcho()*spedSound/2;   
  Serial.print("*X"+String(dis)+"*");    //displaying distance of nearest obstacle on the control device
  
  if (abs(dis)<=maxObst)        //obstacle avoidance feature
  {
    Serial.print("*AR255G0B0*");      //sending an alarming signal to control device
    moveCar(0,0);
    while(abs(dis)<=maxObst)
    {
      if(lineTrc==0)          //if line tracker mode is active the car will stop at obstacles else it will change its direction
      {
        moveCar(0,digiturn);    //turn right
        delay(500);             //for half a second
        moveCar(0,0);           //stop 
      }
      else
      {
        moveCar(0,0);
      }
      dis=obstEcho()*spedSound/2;
      Serial.print("*X"+String(dis)+"*");
      if(dis>maxObst)Serial.print("*AR0G0B0*");     //turning off the alarm signal before exiting the loop
    } 
  }
  
  if (lineTrc==1)               //line tracker mode
  {
    sharpLeftSens=digitalRead(lineTrcVL);
    normLeftSens=!digitalRead(lineTrcL);    //middle three sensors are active low
    middleSens=!digitalRead(lineTrcM);     //reading the sensors values
    normRightSens=!digitalRead(lineTrcR);
    sharpRightSens=digitalRead(lineTrcVR);
        //treating the sensors readings as a binary value and converting into decimal
    lineTrcTurn=sharpLeftSens*16+normLeftSens*8+middleSens*4+normRightSens*2+sharpRightSens;
    switch (lineTrcTurn)
    {
      case 1:                 //  0 0 0 0 1    ->    8
      turnWeight=8;
      break;

      case 3:                 //  0 0 0 1 1    ->   6
      turnWeight=6;
      break;

      case 2:                 //  0 0 0 1 0    ->   4
      turnWeight=4;
      break;

      case 6:                 //  0 0 1 1 0    ->   2
      turnWeight=2;
      break;

      case 4:                 //  0 0 1 0 0    ->   0
      turnWeight=0;
      break;

      case 12:                //  0 1 1 0 0    ->   -2
      turnWeight=-2;
      break;

      case 8:                 //  0 1 0 0 0    ->   -4
      turnWeight=-4;
      break;

      case 24:                //  1 1 0 0 0    ->   -6
      turnWeight=-6;
      break;

      case 16:                //  1 0 0 0 0    ->   -8
      turnWeight=-8;
      break;

      case 0:                 //  0 0 0 0 0    ->   {-9,-7,-5,-3,-1,1,3,5,7,9}(depend on previous state)(intermidiate values for thin tracks)
      if(turnWeight==-4||(turnWeight!=4&&D<0))turnWeight-=1;      //if it was left turn more left
      else if(turnWeight==4||D>0) turnWeight+=1;           //if it was right turn more right
      break;

      default:
      turnWeight=0;             // at conflict move straight
      break;


    }
    P=turnWeight;                   //the proportional value is the current turn weight based on current sensor reading
    I=I+turnWeight;                   //the integral value is the accumulation of all the previous turn weights (readings)
    D=turnWeight-lastTurn;                //the differential value is the difference between current and last turn weights
    turnValue=(P*Pweight)+(I*Iweight)+(D*Dweight);    //finally the turning value which will control the response of the car is the sum of all values
    lastTurn=turnWeight;                //each multiplied by their respective weights
    turnValue=constrain(turnValue,-100,100);
    if(allow==HIGH)
	{moveCar(-1*lineTrcSpe,turnValue);}

    Serial.print("*p");
    Serial.print(P);  //displaying current P on the control device
    Serial.print("*");
    Serial.print("*i");
    Serial.print(I);  //displaying current I on the control device
    Serial.print("*");
    Serial.print("*d");
    Serial.print(D);  //displaying current D on the control device
    Serial.print("*");

  }

  if (Serial.available()>0)     //blue-tooth mode
  {
    reading=Serial.read();
    if(lineTrc==0)
    {
      switch (reading)
      {
        case 'X' :    //the analog pad reading send   X....Y....
        trn=Serial.parseInt();
        reading=Serial.read();
        if(reading=='Y')
        {
          mov=Serial.parseInt();
          moveCar(mov,trn);
        }
        break;

        case 'N' :    //keypad button up
        moveCar(-1*digisped,0);
        break;

        case 'S' :    //keypad button down
        moveCar(digisped,0);
        break;

        case 'E' :    //keypad button right
        moveCar(0,digiturn);
        break;

        case 'W' :    //keypad button left
        moveCar(0,-1*digiturn);
        break;

        case 'R' :    //keypad button up right
        moveCar(-1*digisped,digiturn);
        break;

        case 'L' :    //keypad button up left
        moveCar(-1*digisped,-1*digiturn);
        break;

        case 'A' :    //keypad button down right 
        moveCar(digisped,digiturn);
        break;

        case 'B' :    //keypad button down left 
        moveCar(digisped,-1*digiturn);
        break;

        case 'M' :    //keypad button release and brake button
        moveCar(0,0);
        break;

        case 'C' :    //line tracker activator
        lineTrc=1;
        moveCar(0,0);
        Serial.print("*P");
        Serial.print(Pweight);  //displaying current Pweight on the control device
        Serial.print("*");
        Serial.print("*I");
        Serial.print(Iweight);  //displaying current Iweight on the control device
        Serial.print("*");
        Serial.print("*D");
        Serial.print(Dweight);  //displaying current Dweight on the control device
        Serial.print("*");
        Serial.print("*S");
        Serial.print(lineTrcSpe); //displaying current speed on the control device
        Serial.print("*");
        break;

        default :
        moveCar(0,0);
        break;
      }
    }
    else  
    {
      switch (reading)
      {
        case 'c':
        lineTrc=0;
        moveCar(0,0);
        break;
		
		case 'A':
        allow=HIGH;
        break;
		
		case 'a':
        moveCar(0,0);
		allow=LOW;
        break;

        case 'P':       //for tuning Pweight on the fly
        Pweight=Serial.parseFloat();
        Serial.print("*P");
        Serial.print(Pweight);  //displaying current Pweight on the control device
        Serial.print("*");
        break;

        case 'I':       //for tuning Iweight on the fly
        Iweight=Serial.parseFloat();
        Serial.print("*I");
        Serial.print(Iweight);  //displaying current Iweight on the control device
        Serial.print("*");
        break;

        case 'D':       //for tuning Dweight on the fly
        Dweight=Serial.parseFloat();
        Serial.print("*D");
        Serial.print(Dweight);  //displaying current Dweight on the control device
        Serial.print("*");
        break;

        case 's':       //for tuning speed on the fly
        lineTrcSpe=Serial.parseFloat();
        lineTrcSpe=constrain(lineTrcSpe,-100,100);
        Serial.print("*S");
        Serial.print(lineTrcSpe); //displaying current speed on the control device
        Serial.print("*");
        break;
      }

    }

  }

}
