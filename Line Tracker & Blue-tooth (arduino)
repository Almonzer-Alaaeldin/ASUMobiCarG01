int lineTrcSpe=70;							//for the line tracker mode
float Pweight=20 , Iweight=0 , Dweight=0; 	//These are the weights for every value in PID method used in line tracker to be tunned
#define maxObst     5   					//for tuning max obstacle distance in cm
#define spedSound    0.0343     			//speed of sound in cm/us

#define digisped	70
#define digiturn	70		//for keypad speed and turning

#define LmotorFor    3     //IN1       l298n   motor drive module
#define LmotorBac    2     //IN2
#define LmotorSpe    5     //EN1          
#define RmotorFor    7     //IN3
#define RmotorBac    4     //IN4
#define RmotorSpe    6     //EN2

#define trigUltra    10     //ultra sonic module trigger pin
#define echoUltra    11     //ultra sonic module echo pin

#define lineTrcVL     14      //the very left	//we can use analog pins as digital pins by using numbers from 14-19
#define lineTrcL      15      //the left 
#define lineTrcM      16      //the middle line track sensor
#define lineTrcR      17      //the right 
#define lineTrcVR     18      //the very right

int mov=0 , trn=0 ; //for movement
int dis=0  ; //for ultrasonic sensor
char reading=0 ;  //for blue-tooth readings
bool lineTrc =0 ;  //flag for the line tracker mode
bool sharpRightSens , sharpLeftSens , normRightSens , normLeftSens , middleSens;
int lineTrcTurn=0 , turnWeight=0 , lastTurn=0;
int P=0 , I=0 , D=0 ;		//using the PID method to increase efficiency of line tracking
float  turnValue=0;			

void moveCar(int movment , int turning) //takes percentage of movement and turning the analog stick is reversed in the y direction in the app, up is negative and down is positive
{                                       //positive for backward movement and right turning  negative for forward movement and left turning
	if(movement==0&&turning==0)
	{
		digitalWrite(LmotorFor,LOW);
		digitalWrite(LmotorBac,LOW);	//all pins LOW to stop the car and conserve power
		digitalWrite(LmotorSpe,LOW);
		digitalWrite(RmotorFor,LOW);
		digitalWrite(RmotorBac,LOW);
		digitalWrite(RmotorSpe,LOW);
	}
	else
	{
		int left=0 ,right=0	;				//speed of each wheel
		bool forL=LOW , forR=LOW;			//Direction of each wheel
		if(movement>0)
		{
			turning =-1*turning			//when moving backwards the turning value is reversed
		}
		right=map(turning,-100,100,-255,255);
		left =-1*right;
		left=left+ movement;			
		right=right+movement;
		left=constrain(left,-255,255);
		right=constrain(right,-255,255);
		if (right<0)					//test for negative values to determine direction then make them positive for using
		{
			forR=HIGH;
			right=0-right;
		}	
		else forR=LOW;
		if (left<0)
		{
			forL=HIGH;
			left=0-left;
		}
		else forL=LOW;
		digitalWrite(LmotorFor,forL);
		digitalWrite(LmotorBac,!forL);
		analogWrite(LmotorSpe,left);
		digitalWrite(RmotorFor,forR);
		digitalWrite(RmotorBac,!forR);
		analogWrite(RmotorSpe,right);
	}
}

int obstEcho()					//the generic code for the ultrasonic module
{
  int tim=0
  digitalWrite(trigUltra, LOW);
  delayMicroseconds(2);
  digitalWrite(trigUltra, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigUltra, LOW);
  tim= pulseIn(echoUltra, HIGH);
  return tim;
}

void setup() 
{
 Serial.begin(9600);
 pinMode(LmotorFor,OUTPUT);
 pinMode(LmotorBac,OUTPUT);
 pinMode(LmotorSpe,OUTPUT);
 pinMode(RmotorFor,OUTPUT);
 pinMode(RmotorBac,OUTPUT);
 pinMode(RmotorSpe,OUTPUT);

 pinMode(trigUltra,OUTPUT);
 pinMode(echoUltra,INPUT);

 pinMode(lineTrcVL,INPUT);
 pinMode(lineTrcL,INPUT);
 pinMode(lineTrcM,INPUT);
 pinMode(lineTrcR,INPUT);
 pinMode(lineTrcVR,INPUT);
 
}

void loop() 
{
  dis=obstEcho()*spedSound/2;		
  Serial.print("*X");
  Serial.print(dis);				//displaying distance of nearest obstacle on the control device
  Serial.print("*");

  while (dis<=maxObst)				//obstacle avoidance feature
  {
    Serial.print("*A*");			//sending an alarming signal to control device
    if(lineTrc==0)					//if line tracker mode is active the car will stop at obstacles else it will change its direction
    {
		moveCar(0,digiturn); 		//turn right
    }
	else
	{
		moveCar(0,0);
	}
    dis=obstEcho()*spedSound/2;
	if(dis>maxObst)Serial.print("*A*");			//turning off the alarm signal before exiting the loop
  }
  
  if (lineTrc==1)								//line tracker mode
  {
	sharpLeftSens=digitalRead(lineTrcVL);
	normLeftSens=digitalRead(lineTrcL);
	middleSens=digitalRead(lineTrcM);			//reading the sensors values
	normRightSens=digitalRead(lineTrcR);
	sharpRightSens=digitalRead(lineTrcVR);
												//treating the sensors readings as a binary value and converting into decimal
	lineTrcTurn=sharpLeftSens*16+normLeftSens*8+middleSens*4+normRightSens*2+sharpRightSens;
	switch (lineTrcTurn)
	{
		case 1:									//  0 0 0 0 1    ->    4
		turnWeight=4;
		break;
		
		case 3:									//  0 0 0 1 1    ->   3
		turnWeight=3;
		break;
		
		case 2:									//  0 0 0 1 0    ->   2
		turnWeight=2;
		break;
		
		case 6:									//  0 0 1 1 0    ->   1
		turnWeight=1;
		break;
		
		case 4:									//  0 0 1 0 0    ->   0
		turnWeight=0;
		break;
		
		case 12:								//  0 1 1 0 0    ->   -1
		turnWeight=-1;
		break;
		
		case 8:									//  0 1 0 0 0    ->   -2
		turnWeight=-2;
		break;
		
		case 24:								//  1 1 0 0 0    ->   -3
		turnWeight=-3;
		break;
		
		case 16:								//  1 0 0 0 0    ->   -4
		turnWeight=-4;
		break;
		
		case 0:									//  0 0 0 0 0    ->   -5 or 5 (depend on previous state)
		if(turnWeight<0)turnWeight=-5;			//if it was left turn more left
		else turnWeight=5;						//if it was right turn more right
		break;
		
		default:
		turnWeight=0;							// at conflict move straight
		break;
		
		
	}
	P=turnWeight;										//the proportional value is the current turn weight based on current sensor reading
	I=I+turnWeight;										//the integral value is the accumulation of all the previous turn weights (readings)
	D=turnWeight-lastTurn;								//the differential value is the difference between current and last turn weights
	turnValue=(P*Pweight)+(I*Iweight)+(D*Dweight);		//finally the turning value which will control the response of the car is the sum of all values
	lastTurn=turnWeight;								//each multiplied by their respective weights
	turnValue=constrain(turnValue,-100,100);
	moveCar(lineTrcSpe,turnValue);
	
	Serial.print("*p");
	Serial.print(P);	//displaying current P on the control device
	Serial.print("*");
	Serial.print("*i");
	Serial.print(I);	//displaying current I on the control device
	Serial.print("*");
	Serial.print("*d");
	Serial.print(D);	//displaying current D on the control device
	Serial.print("*");
	
  }
  
  if (Serial.available()>0)			//blue-tooth mode
  {
    reading=Serial.read();
	if(lineTrc==0)
	{
		switch (reading)
		{
			case 'X' :		//the analog pad reading send   X....Y....
			trn=Serial.read();
			reading=Serial.read();
			if(reading=='Y')
			{
				mov=Serial.read();
				moveCar(mov,trn);
			}
			break;
			
			case 'N' : 		//keypad button up
			moveCar(-1*digisped,0);
			break;
			
			case 'S' :		//keypad button down
			moveCar(digisped,0);
			break;
			
			case 'E' :		//keypad button right
			moveCar(0,digiturn);
			break;
			
			case 'W' :		//keypad button left
			moveCar(0,-1*digiturn);
			break;
			
			case 'R' :		//keypad button up right
			moveCar(-1*digisped,digiturn);
			break;
			
			case 'L' :		//keypad button up left
			moveCar(-1*digisped,-1*digiturn);
			break;
			
			case 'A' :		//keypad button down right 
			moveCar(*digisped,digiturn);
			break;
			
			case 'B' :		//keypad button down left 
			moveCar(*digisped,-1*digiturn);
			break;
			
			case 'M' :		//keypad button release and brake button
			moveCar(0,0);
			break;
			
			case 'C' :		//line tracker activator
			lineTrc=1;
			moveCar(0,0);
			Serial.print("*P");
			Serial.print(Pweight);	//displaying current Pweight on the control device
			Serial.print("*");
			Serial.print("*I");
			Serial.print(Iweight);	//displaying current Iweight on the control device
			Serial.print("*");
			Serial.print("*D");
			Serial.print(Dweight);	//displaying current Dweight on the control device
			Serial.print("*");
			Serial.print("*S");
			Serial.print(lineTrcSpe);	//displaying current speed on the control device
			Serial.print("*");
			break;
			
			default :
			moveCar(0,0);
			break;
		}
	}
	else  
	{
		switch (reading)
		{
			case 'c':
			lineTrc=0;
			moveCar(0,0);
			break;
			
			case 'P':				//for tuning Pweight on the fly
			Pweight=Serial.read();
			Serial.print("*P");
			Serial.print(Pweight);	//displaying current Pweight on the control device
			Serial.print("*");
			break;
			
			case 'I':				//for tuning Iweight on the fly
			Iweight=Serial.read();
			Serial.print("*I");
			Serial.print(Iweight);	//displaying current Iweight on the control device
			Serial.print("*");
			break;
			
			case 'D':				//for tuning Dweight on the fly
			Dweight=Serial.read();
			Serial.print("*D");
			Serial.print(Dweight);	//displaying current Dweight on the control device
			Serial.print("*");
			break;
			
			case 's':				//for tuning speed on the fly
			lineTrcSpe=Serial.read();
			LineTrcSpe=constrain(lineTrcSpe,-100,100);
			Serial.print("*S");
			Serial.print(lineTrcSpe);	//displaying current speed on the control device
			Serial.print("*");
			break;
		}
		
	}
	
  }
  
  
  

}
